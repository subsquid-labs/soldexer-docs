---
title: "Adding a custom transformer"
description: "Transform raw Portal data in Solana pipes"
---

## Adding Transformer

Extract transaction hashes from instructions.

**Use case**: Transform raw Portal data before logging.

```ts expandable
import { createTarget, createTransformer } from "@subsquid/pipes";
import {
  solanaPortalSource,
  type SolanaPortalData,
  SolanaQueryBuilder,
} from "@subsquid/pipes/solana";

const queryBuilder = new SolanaQueryBuilder()
  .addFields({
    block: { slot: true, hash: true },
    instruction: { programId: true, data: true, accounts: true, transactionHash: true },
  })
  .addInstruction({
    request: {
      programId: ["whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"],
      d8: ["0xf8c69e91e17587c8"],
    },
    range: { from: 200000000, to: 200000000 },
  });

const source = solanaPortalSource({
  portal: "https://portal.sqd.dev/datasets/solana-mainnet",
  query: queryBuilder,
});

const transformer = createTransformer({
  transform: async (data: SolanaPortalData<any>) => {
    return data.blocks.map((b) => b.instructions.map((i) => i.transactionHash));
  },
});

const target = createTarget({
  write: async ({ logger, read }) => {
    for await (const { data } of read()) {
      logger.info({ data }, "transaction hashes");
    }
  },
});

await source.pipe(transformer).pipeTo(target);
```

## Query from Transformer

Build query dynamically in transformer.

**Use case**: Self-contained transformers that specify their own data requirements.

```ts expandable
import { createTarget, createTransformer } from "@subsquid/pipes";
import {
  solanaPortalSource,
  type SolanaPortalData,
  SolanaQueryBuilder,
} from "@subsquid/pipes/solana";

// Start with empty query
const source = solanaPortalSource({
  portal: "https://portal.sqd.dev/datasets/solana-mainnet",
  query: new SolanaQueryBuilder(),
});

// Transformer adds to query
const transformer = createTransformer({
  query: ({ queryBuilder }) => {
    queryBuilder
      .addFields({
        block: { slot: true, hash: true },
        instruction: { programId: true, data: true, accounts: true, transactionHash: true },
      })
      .addInstruction({
        request: {
          programId: ["whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc"],
          d8: ["0xf8c69e91e17587c8"],
        },
        range: { from: 200000000, to: 200000000 },
      });
  },
  transform: async (data: SolanaPortalData<any>) => {
    return data.blocks.map((b) => b.instructions.map((i) => i.transactionHash));
  },
});

const target = createTarget({
  write: async ({ logger, read }) => {
    for await (const { data } of read()) {
      logger.info({ data }, "data");
    }
  },
});

await source.pipe(transformer).pipeTo(target);
```

<Note>
**Key Distinction**: Transformers can operate in two ways:
- **Pure transformation** (first example): Only implements `transform()` — processes data after the Portal query is executed.
- **Query-aware transformation** (second example): Implements both `query()` and `transform()` — contributes to building the Portal query and processes the resulting data.

When a transformer has a `query()` method, it augments the Portal query before data is fetched, allowing transformers to be self-contained with their data requirements.
</Note>

<Tip>
For better type safety and developer experience, use `solanaInstructionDecoder` with ABIs generated by `@subsquid/solana-typegen`. See the [Instruction Decoding](/en/sdk/pipes-sdk/guides/instruction-decoding) guide for a typed approach.
</Tip>
